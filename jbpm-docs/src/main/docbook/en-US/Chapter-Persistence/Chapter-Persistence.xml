<?xml version="1.0" encoding="UTF-8"?>
<chapter id="ch.core-persistence"
         version="5.0"
         xsi:schemaLocation="http://docbook.org/ns/docbook http://www.docbook.org/xml/5.0/xsd/docbook.xsd http://www.w3.org/1999/xlink http://www.docbook.org/xml/5.0/xsd/xlink.xsd"
         xml:base="../" xmlns="http://docbook.org/ns/docbook" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:ns="http://docbook.org/ns/docbook">

  <title>Core Engine: Persistence and transactions</title>

  <para>jBPM allows the persistent storage of certain information,
  i.e., the process runtime state, the history information, etc.</para>

  <section>
    <title>Runtime State</title>

    <para>Whenever a process is started, a process instance is created, which
    represents the execution of the process in that specific context.  For example,
    when executing a process that specifies how to process a sales order, one process
    instance is created for each sales request.  The process instance represents
    the current execution state in that specific context, and contains all the
    information related to that process instance.  Note that it only contains
    the minimal runtime state that is needed to continue the execution of that
    process instance at some later time, but it does not include information
    about the history of that process instance if that information is no longer
    needed in the process instance.</para>

    <para>The runtime state of an executing process can be made persistent,
    for example, in a database.  This allows to restore the state of
    execution of all running processes in case of unexpected failure,
    or to temporarily remove running instances from memory and restore
    them at some later time.  jBPM allows you to plug in different
    persistence strategies.  By default, if you do not configure the
    process engine otherwise, process instances are not made persistent.</para>

    <para>The runtime persistence data should in general be considered internal, meaning that you
    probably should not try to access these database tables directly and especially not try
    to modify these directly (as changing the runtime state of process instances without the
    engine knowing might have unexpected side-effects).  In most cases where information about
    the current execution state of process instances is required, the use of a history log
    is mostly recommended (see below).  In some cases, it might still be useful to for example
    query the internal database tables directly, but you should only do this if you know what
    you are doing.</para>

    <section>
      <title>Binary Persistence</title>
    
    <para>jBPM uses a binary persistence mechanism, otherwise known
    as marshalling, which converts the state of the process instance
    into a binary dataset. When you use persistence with jBPM, this 
    mechanism is used to save or retrieve the process instance state 
    from the database. The same mechanism is also applied to the 
    session state and any work item states.</para> 

    <para>When the process instance state is persisted, two things
    happen: 
    <itemizedlist>
      <listitem>First, the process instance information is transformed 
      into a binary blob. For performance reasons, a custom serialization 
      mechanism is used and not normal Java serialization.</listitem>
      <listitem>This blob is then stored, alongside other metadata about 
      this process instance. This metadata includes, among other things, 
      the process instance id, process id, and the process start date.</listitem>
    </itemizedlist>
    </para>

    <para>Apart from the process instance state, the session itself can 
    also store some state, such as the state of timer jobs, or the session 
    data that the any business rules would be evaluated over.  
    This session state is stored separately as a binary blob, along with 
    the id of the session and some metadata. You can always restore session 
    state by reloading the session with the given id.  The session id can 
    be retrieved using <code>ksession.getId()</code>.</para>

    <para>Note that the process instance binary datasets are usually 
    relatively small, as they only contain the minimal execution state 
    of the process instance.  For a simple process instance, this usually 
    contains one or a few node instances, i.e., any node that is currently 
    executing, and any existing variable values.</para>
    
    <para>As a result of jBPM using marshalling, the data model is both 
    simple and small:</para>

    <!-- width && scalefit for pdf's -->
    <ulink url="images/Chapter-Persistence/jbpm_schema.png">
      <figure>
        <title>jBPM data model</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/Chapter-Persistence/jbpm_schema_doc.png" format="PNG" 
                       align="center" width="100%" scalefit="1" />
          </imageobject>
        </mediaobject>
      </figure>
    </ulink>

    <para>The <code>sessioninfo</code> entity contains the state of the 
    (knowledge) session in which the jBPM process instance is running. 
    This entity contains the following fields:
      <itemizedlist>
        <listitem><code>id</code>: the primary key</listitem>
        <listitem><code>lastmodificationdate</code>: the last time that 
        the entity was saved to the database</listitem>
        <listitem><code>rulesbytearray</code>: this is the binary dataset 
        containing the state of the session</listitem>
        <listitem><code>startdate</code>: The start time of the session 
        </listitem>
        <listitem><code>optlock</code>: the version field that serves as 
        its optimistic lock value</listitem>
      </itemizedlist>
    </para>

    <para>The <code>processinstanceinfo</code> entity contains the state 
    of the jBPM process instance, including the following fields:
      <itemizedlist>
        <listitem><code>instanceid</code>: the primary key</listitem>
        <listitem><code>lastmodificationdate</code>: the last time that 
        the entity was saved to the database</listitem>
        <listitem><code>lastreaddate</code>: the last time that 
        the entity was retrieved (read) from the database</listitem>
        <listitem><code>processid</code>: the name (id) of the process
        </listitem>
        <listitem><code>processinstancebytearray</code>: this is the binary 
        dataset containing the state of the process instance</listitem>
        <listitem><code>startdate</code>: The start time of the process
        </listitem>
        <listitem><code>state</code>: an integer representing the state 
        of the process instance</listitem>
        <listitem><code>optlock</code>: the version field that serves as 
        its optimistic lock value</listitem>
      </itemizedlist>
    </para>

    <para>The <code>workiteminfo</code> entity contains the state of a
    work item, including the following fields:
      <itemizedlist>
        <listitem><code>workitemid</code>: the primary key</listitem>
        <listitem><code>name</code>: the name of the work item</listitem>
        <listitem><code>processinstanceid</code>: the (primary key) id
        of the process. There is not a foreign key constraint on this 
        field</listitem>
        <listitem><code>state</code>: an integer representing the state 
        of the work item</listitem>
        <listitem><code>optlock</code>: the version field that serves as 
        its optimistic lock value</listitem>
        <listitem><code>workitembytearay</code>: this is the binary dataset 
        containing the state of the work item</listitem>
      </itemizedlist>
    </para>

    </section>

    <section>
      <title>Safe Points</title>

    <para>The state of a process instance is stored at so-called "safe points"
    during the execution of the process engine.  Whenever a process instance
    is executing, after its start or continuation from a wait state, the engine
    proceeds until no more actions can be performed. At that point, the engine
    has reached the next safe state, and the state of the process instance
    and all other process instances that might have been affected is stored
    persistently.</para>
    </section>

    <section>
      <title>Configuring Persistence</title>

    <para>By default, the engine does not save runtime data persistently.
    It is, however, pretty straightforward to configure the engine to do
    this, by adding a configuration file and the necessary dependencies.
    Persistence itself is based on the Java Persistence API (JPA) and can
    thus work with several persistence mechanisms.  We are using Hibernate by
    default, but feel free to employ alternatives.  A H2 database is used
    underneath to store the data, but you might choose your own alternative
    for this, too.</para>

    <para>First of all, you need to add the necessary dependencies to your
    classpath.  If you're using the Eclipse IDE, you can do that by adding
    the jar files to your jBPM runtime directory,
    or by manually adding these dependencies to your project. First of all,
    you need the jar file <filename>jbpm-persistence-jpa.jar</filename>,
    as that contains code for saving the runtime state whenever necessary.
    Next, you also need various other dependencies, depending on the
    persistence solution and database you are using.  For the default
    combination with Hibernate as the JPA persistence provider, the H2
    database and Bitronix for JTA-based transaction management, the
    following list of additional dependencies is needed:
      <orderedlist>
        <listitem>jbpm-persistence-jpa (org.jbpm)</listitem>
        <listitem>drools-persistence-jpa (org.drools)</listitem>
        <listitem>persistence-api (javax.persistence)</listitem>
        <listitem>hibernate-entitymanager (org.hibernate)</listitem>
        <listitem>hibernate-annotations (org.hibernate)</listitem>
        <listitem>hibernate-commons-annotations (org.hibernate)</listitem>
        <listitem>hibernate-core (org.hibernate)</listitem>
        <listitem>dom4j (dom4j)</listitem>
        <listitem>jta (javax.transaction)</listitem>
        <listitem>btm (org.codehaus.btm)</listitem>
        <listitem>javassist (javassist)</listitem>
        <listitem>slf4j-api (org.slf4j)</listitem>
        <listitem>slf4j-jdk14 (org.slf4j)</listitem>
        <listitem>h2 (com.h2database)</listitem>
        <listitem>commons-collections (commons-collections)</listitem>
      </orderedlist>
    </para>

    <para>Next, you need to configure the jBPM engine to save the state of the
    engine whenever necessary.  The easiest way to do this is to use
    <code>JPAKnowledgeService</code> to create your knowledge session, based on a
    knowledge base, a knowledge session configuration (if necessary) and an
    environment.  The environment needs to contain a reference to your
    Entity Manager Factory.  For example:</para>

    <programlisting language="java">// create the entity manager factory and register it in the environment
EntityManagerFactory emf =
    Persistence.createEntityManagerFactory( "org.jbpm.persistence.jpa" );
Environment env = KnowledgeBaseFactory.newEnvironment();
env.set( EnvironmentName.ENTITY_MANAGER_FACTORY, emf );

// create a new knowledge session that uses JPA to store the runtime state
StatefulKnowledgeSession ksession =
    JPAKnowledgeService.newStatefulKnowledgeSession( kbase, null, env );
int sessionId = ksession.getId();

// invoke methods on your method here
ksession.startProcess( "MyProcess" );
ksession.dispose();</programlisting>

    <para>You can also yse the <code>JPAKnowledgeService</code> to recreate
    a session based on a specific session id:</para>

    <programlisting language="java">
// recreate the session from database using the sessionId
ksession = JPAKnowledgeService.loadStatefulKnowledgeSession( sessionId, kbase, null, env );</programlisting>

    <!--para>You can also configure your engine to use persistence by simply specifying this in your session
    configuration.  There are various ways to do this, but using a simple drools.session.conf file in a
    META-INF directory on your classpath is probably the easiest way (check the documentation for other
    ways of configuring your session, for example by providing a KnowledgeSessionConfiguration when first creating your
    session).  In this config file you need to do two things: tell the engine that it needs to use
    a command service underneath (as commands are used to determine safe points during the execution of
    the engine), and use the JPA-based implementations of 3 internal components (the process instance
    manager, the work item manager and the signal manager), as these components will then be able to
    look up the necessary information from persistence using JPA.  The drools.session.conf file should
    thus look like this:</para>

    <programlisting>
drools.commandService = org.drools.persistence.session.SingleSessionCommandService
drools.processInstanceManagerFactory = org.drools.persistence.processinstance.JPAProcessInstanceManagerFactory
drools.workItemManagerFactory = org.drools.persistence.processinstance.JPAWorkItemManagerFactory
drools.processSignalManagerFactory = org.drools.persistence.processinstance.JPASignalManagerFactory</programlisting-->

    <para>Note that we only save the minimal state that is needed to continue
    execution of the process instance at some later point.  This means, for example, that
    it does not contain information about already executed nodes if that information
    is no longer relevant, or that process instances that have been completed or
    aborted are removed from the database.  If you want to search for history-related
    information, you should use the history log, as explained later.</para>

    <para>You need to add a persistence configuration to your classpath to 
    configures JPA to use Hibernate and the H2 database (or your preference), called
    <filename>persistence.xml</filename> in the META-INF directory, as shown below.
    For more details on how to change this for your own configuration, we refer to
    the JPA and Hibernate documentation for more information.</para>

    <programlisting language="xml">&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;persistence
  version="1.0"
  xsi:schemaLocation=
    "http://java.sun.com/xml/ns/persistence
     http://java.sun.com/xml/ns/persistence/persistence_1_0.xsd
     http://java.sun.com/xml/ns/persistence/orm
     http://java.sun.com/xml/ns/persistence/orm_1_0.xsd"
  xmlns:orm="http://java.sun.com/xml/ns/persistence/orm"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns="http://java.sun.com/xml/ns/persistence"&gt;

  &lt;persistence-unit name="org.jbpm.persistence.jpa"&gt;
    &lt;provider&gt;org.hibernate.ejb.HibernatePersistence&lt;/provider&gt;
    &lt;jta-data-source&gt;jdbc/processInstanceDS&lt;/jta-data-source&gt;
    &lt;class&gt;org.drools.persistence.info.SessionInfo&lt;/class&gt;
    &lt;class&gt;org.jbpm.persistence.processinstance.ProcessInstanceInfo&lt;/class&gt;
    &lt;class&gt;org.drools.persistence.info.WorkItemInfo&lt;/class&gt;

    &lt;properties&gt;
      &lt;property name="hibernate.dialect" value="org.hibernate.dialect.H2Dialect"/&gt;
      &lt;property name="hibernate.max_fetch_depth" value="3"/&gt;
      &lt;property name="hibernate.hbm2ddl.auto" value="update"/&gt;
      &lt;property name="hibernate.show_sql" value="true"/&gt;
      &lt;property name="hibernate.transaction.manager_lookup_class"
                value="org.hibernate.transaction.BTMTransactionManagerLookup"/&gt;
    &lt;/properties&gt;
  &lt;/persistence-unit&gt;
&lt;/persistence&gt;</programlisting>

    <para>This configuration file refers to a data source called "jdbc/processInstanceDS".
    The following Java fragment could be used to set up this data source, where
    we are using the file-based H2 database.</para>

    <programlisting language="java">PoolingDataSource ds = new PoolingDataSource();
ds.setUniqueName("jdbc/testDS1");
ds.setClassName("org.h2.jdbcx.JdbcDataSource");
ds.setMaxPoolSize(3);
ds.setAllowLocalTransactions(true);
ds.getDriverProperties().put("user", "sa");
ds.getDriverProperties().put("password", "sasa");
ds.getDriverProperties().put("URL", "jdbc:h2:file:/NotBackedUp/data/process-instance-db");
ds.init();</programlisting>

    <para>If you're deploying to an application server, you can usually create a datasource
    by dropping a configuration file in the deploy directory, for example:</para>
    
    <programlisting language="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;datasources&gt;
  &lt;local-tx-datasource&gt;
    &lt;jndi-name&gt;jdbc/testDS1&lt;/jndi-name&gt;
    &lt;connection-url&gt;jdbc:h2:file:/NotBackedUp/data/process-instance-db&lt;/connection-url&gt;
    &lt;driver-class&gt;org.h2.jdbcx.JdbcDataSource&lt;/driver-class&gt;
    &lt;user-name&gt;sa&lt;/user-name&gt;
    &lt;password&gt;sasa&lt;/password&gt;
  &lt;/local-tx-datasource&gt;
&lt;/datasources&gt;</programlisting>

    <!--para>After adding the necessary dependencies and the configuration file to your project, you can simply
    use the StatelessKnowledgeSession just the way you used to do.  The engine will underneath translate your
    invocations to commands that will persist the state of the engine after each successful execution of a
    command.  For example, the following code snippet shows how to create a session and start a process.  Note
    that this snippet does not show anything about persistence (as the config file configures all that for you,
    and the engine takes care of it automatically), so the example looks just like normal Drools code.  You
    can however always destroy your session and create a new one (or one session could continue the work
    that was started in another session), as the runtime state is persisted safely in a database, and can be
    retrieved whenever necessary.</para>

    <programlisting language="java">
  StatefulKnowledgeSession session = kbase.newStatefulKnowledgeSession();
  long processInstanceId = session.startProcess("org.drools.test.TestProcess").getId();
  session.dispose();</programlisting-->
    </section>

    <section>
      <title>Transactions</title>

    <para>Whenever you do not provide transaction boundaries inside your application,
    the engine  will automatically execute each method invocation on the engine
    in a separate transaction.  If this behavior is acceptable, you don't need to do
    anything else.  You can, however, also specify the transaction boundaries yourself.
    This allows you, for example, to combine multiple commands into one transaction.</para>

    <para>You need to register a transaction manager at the environment before
    using user-defined transactions.  The following sample code uses the Bitronix
    transaction manager.  Next, we use the Java Transaction API (JTA)
    to specify transaction boundaries, as shown below:</para>

    <programlisting language="java">// create the entity manager factory and register it in the environment
EntityManagerFactory emf =
    Persistence.createEntityManagerFactory( "org.jbpm.persistence.jpa" );
Environment env = KnowledgeBaseFactory.newEnvironment();
env.set( EnvironmentName.ENTITY_MANAGER_FACTORY, emf );
env.set( EnvironmentName.TRANSACTION_MANAGER,
         TransactionManagerServices.getTransactionManager() );

// create a new knowledge session that uses JPA to store the runtime state
StatefulKnowledgeSession ksession =
    JPAKnowledgeService.newStatefulKnowledgeSession( kbase, null, env );

// start the transaction
UserTransaction ut =
  (UserTransaction) new InitialContext().lookup( "java:comp/UserTransaction" );
ut.begin();

// perform multiple commands inside one transaction
ksession.insert( new Person( "John Doe" ) );
ksession.startProcess( "MyProcess" );

// commit the transaction
ut.commit();</programlisting>

    </section>

  </section>

  <section>
    <title>Process Definitions</title>

    <para>Process definition files are usually written in an XML format.  These
    files can easily be stored on a file system during development.  However,
    whenever you want to make your knowledge accessible to one or more engines
    in production, we recommend using a knowledge repository that (logically)
    centralizes your knowledge in one or more knowledge repositories.</para>

    <para>Guvnor is a Drools sub-project that does exactly that. It 
    consists of a repository for storing different kinds of knowledge, as 
    well a web application that allows users to view and update the information 
    in the repository. It not only stores process definitions but also 
    can hold rule definitions, object models, and much more.</para>
    
    <para>Easy programmatic retrieval of knowledge packages is possible 
    either using WebDAV or by using a knowledge agent. The knowledge
    agent will automatically download the information from Guvnor, for example, 
    during the creation of a knowledge base.</para>

    <para>Check out the Drools Guvnor documentation for more information on how to
    do this.</para>

  </section>

  <section>
    <title>History Log</title>

    <para>In many cases it will be useful (if not necessary) to store information
    <emphasis>about</emphasis> the execution of process instances, so that 
    this information can be used afterwards. For example, sometimes we 
    want to verify which actions have been executed for a particular process 
    instance, or in general, we want to be able to monitor and analyze 
    the efficiency of a particular process.</para>
    
    <para>However, storing history information in the runtime database 
    can result in the database rapidly increasing in size, not to mention 
    the fact that monitoring and analysis queries might influence the performance 
    of your runtime engine. This is why process execution history information 
    can be stored separately.</para>

    <para>This history log of execution information is created based on 
    events that the the process engine generates during execution. This is 
    possible because the jBPM runtime engine provides a generic mechanism 
    to listen to events. The necessary information can easily be extracted 
    from these events and then persisted to a database. Filters can also be 
    used to limit the scope of the logged information.</para>

    <section>
      <title>The Business Activity Monitoring data model</title>

      <para>The jbpm-bam module contains an event listener that stores
      process-related information in a database using JPA or Hibernate directly.
      The data model itself contains three entities, one for process instance 
      information, one for node instance information, and one for (process) 
      variable instance information (see the figure below):
      <orderedlist>
        <listitem><emphasis>ProcessInstanceLog:</emphasis> This table contains
        the following fields: 
        <itemizedlist>
          <listitem><code>id</code>: the primary key and id of the log entity</listitem>
          <listitem><code>end_date</code>: when applicable, the end date of the process instance</listitem>
          <listitem><code>processinstanceid</code>: the process instance id</listitem>
          <listitem><code>start_date</code>: the start date of the process instance</listitem>
        </itemizedlist>
        </listitem>

        <listitem><emphasis>NodeInstanceLog:</emphasis> This table contains
        more information about which nodes were actually executed inside 
        each process instance.  Whenever a node instance is entered from 
        one of its incomming connections or is exited through one of its 
        outgoing connections, that information is stored in this table.

        <itemizedlist>
          <listitem><code>id</code>: the primary key and id of the log entity</listitem>
          <listitem><code>log_date</code>: the date of the event</listitem>
          <listitem><code>nodeid</code>: the node id of the corresponding node in the process definition</listitem>
          <listitem><code>nodeinstanceid</code>: the node instance id</listitem>
          <listitem><code>nodename</code>: the name of the node</listitem>
          <listitem><code>processid</code>: the id of the process that the process instance is executing</listitem>
          <listitem><code>processinstanceid</code>: the process instance id</listitem>
          <listitem><code>type</code>: the type of the event (0 = enter, 1 = exit)</listitem>
        </itemizedlist>
        </listitem>

        <listitem><emphasis>VariableInstanceLog:</emphasis> This table contains 
        information about changes in variable instances. The defaul is to only
        generate log entries when (after) a variable changes. It's also 
        possible to log entries before the variable (value) changes. 
        
        <itemizedlist>
          <listitem><code>id</code>: the primary key and id of the log entity</listitem>
          <listitem><code>log_date</code>: the date of the event</listitem>
          <listitem><code>processid</code>: the id of the process that the process instance is executing</listitem>
          <listitem><code>processinstanceid</code>: the process instance id</listitem>
          <listitem><code>value</code>: the value of the variable at the time that the log is made</listitem>
          <listitem><code>variableid</code>: the variable id in the process definition</listitem>
          <listitem><code>variableinstanceid</code>: the id of the variable instance</listitem>
        </itemizedlist>

        </listitem>

      </orderedlist>
      </para>

      <!-- width && scalefit for pdf's -->
      <figure>
        <title>Business Activity Monitoring data model</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/Chapter-Persistence/bam_schema.png" format="PNG" 
                       align="center" width="100%" scalefit="1" />
          </imageobject>
        </mediaobject>
      </figure>
  
    </section>

    <section>
      <title>Storing Process Events in a Database</title>

      <para>To log process history information in a database like this, you
      need to register the logger on your session (or working memory) like
      this:</para>
      <programlisting language="java">
StatefulKnowledgeSession ksession = ...;
JPAWorkingMemoryDbLogger logger = new JPAWorkingMemoryDbLogger(ksession);

// invoke methods one your session here

logger.dispose();</programlisting>

      <para>Note that this logger is like any other audit logger, which means
      that you can add one or more filters by calling the method
      <code>addFilter</code> to ensure that only relevant information is
      stored in the database.  Only information accepted by all your filters will
      appear in the database.  You should dispose the logger when it is no
      longer needed.</para>

      <para>To specify the database where the information should be stored,
      modify the file <filename>persistence.xml</filename> file to include
      the audit log classes as well (ProcessInstanceLog, NodeInstanceLog and
      VariableInstanceLog), as shown below.</para>
      
    <programlisting language="xml">&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;persistence
  version="1.0"
  xsi:schemaLocation=
    "http://java.sun.com/xml/ns/persistence
     http://java.sun.com/xml/ns/persistence/persistence_1_0.xsd
     http://java.sun.com/xml/ns/persistence/orm
     http://java.sun.com/xml/ns/persistence/orm_1_0.xsd"
  xmlns:orm="http://java.sun.com/xml/ns/persistence/orm"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns="http://java.sun.com/xml/ns/persistence"&gt;

  &lt;persistence-unit name="org.jbpm.persistence.jpa"&gt;
    &lt;provider&gt;org.hibernate.ejb.HibernatePersistence&lt;/provider&gt;
    &lt;jta-data-source&gt;jdbc/processInstanceDS&lt;/jta-data-source&gt;
    &lt;class&gt;org.drools.persistence.info.SessionInfo&lt;/class&gt;
    &lt;class&gt;org.jbpm.persistence.processinstance.ProcessInstanceInfo&lt;/class&gt;
    &lt;class&gt;org.drools.persistence.info.WorkItemInfo&lt;/class&gt;
    &lt;class&gt;org.jbpm.process.audit.ProcessInstanceLog&lt;/class&gt;
    &lt;class&gt;org.jbpm.process.audit.NodeInstanceLog&lt;/class&gt;
    &lt;class&gt;org.jbpm.process.audit.VariableInstanceLog&lt;/class&gt;

    &lt;properties&gt;
      &lt;property name="hibernate.dialect" value="org.hibernate.dialect.H2Dialect"/&gt;
      &lt;property name="hibernate.max_fetch_depth" value="3"/&gt;
      &lt;property name="hibernate.hbm2ddl.auto" value="update"/&gt;
      &lt;property name="hibernate.show_sql" value="true"/&gt;
      &lt;property name="hibernate.transaction.manager_lookup_class"
                value="org.hibernate.transaction.BTMTransactionManagerLookup"/&gt;
    &lt;/properties&gt;
  &lt;/persistence-unit&gt;
&lt;/persistence&gt;</programlisting>      

      <para>All this information can easily be queried and used in a lot of
      different use cases, ranging from creating a history log for one
      specific process instance to analyzing the performance of all instances
      of a specific process.</para>
      
      <para>This audit log should only be considered a default implementation.
      We don't know what information you need to store for analysis afterwards,
      and for performance reasons it is recommended to only store the relevant
      data.  Depending on your use cases, you might define your own data model
      for storing the information you need, and use the process event listeners
      to extract that information.</para>
    </section>

  </section>

</chapter>
